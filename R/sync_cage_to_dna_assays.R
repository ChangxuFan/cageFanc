### the sync.o object:
# It's a list. Elements: j; cage.se; and atac.se
# sync.o$j: the "official" ranges. annotations are made to j. it initally stands for the join between cage and atac ranges
# for a valid sync.o, it should be "synced" already. 
##This means that cage.se and atac.se should have exactly the same number of rows.
# mapping between elements: they are mapped through rownames.
#######
# legacy version (script: sync_cage_to_dna_assays_legacy.R): 
#the legacy version uses row number for mapping. j carries a critical column named "id". 
#This column should be kept as 1:length(j) at all times. This means after subsetting or combination, id should be reset
# the legacy version was used in range.cor.2, sync.o.rescue, and sync.atac.2.cage.2
# there is an even older version. It's completely obsolete.


se.fast.normalize <- function(se, factor = 1000000, slot.name = "cpm") {
  counts.mat <- assays(se)$counts
  if (ncol(counts.mat) == 1) {
    assays(se)[[slot.name]] <- counts.mat %*% (1/colSums(counts.mat, na.rm = T)) * factor
  } else if (ncol(counts.mat) > 1) {
    assays(se)[[slot.name]] <- counts.mat %*% diag(1/colSums(counts.mat, na.rm = T)) * factor
  } else {
    stop("incorrect dimentions of assay(se)$counts")
  }
  
  metadata(se)$scale.factor <- factor
  return(se)
}

cager.get.counts <- function(ce, gr, consensus = T, samples = NULL, return.se = F) {
  warning("the consensus generated by this function is different from that of aggregateTagClusters\n" %>% 
            paste0("this is because I don't have any filters. However, it's shown that they correlate with each other well"))
  if (is.null(samples))
    samples <- ce$sampleLabels
  else
    samples <- ce$sampleLabels %>% .[.%in% samples]
  mcols(gr) <- NULL
  names(gr) <- NULL
  tpm.gr <- rowRanges(ce@ExperimentList$tagCountMatrix)
  tpm.mat <- assays(ce@ExperimentList$tagCountMatrix)$normalizedTpmMatrix 
  mcols(tpm.gr) <- tpm.mat
  gr$id <- 1:length(gr)
  # browser()
  j <- plyranges::join_overlap_left_directed(gr, tpm.gr) %>% as.data.frame() %>% 
    group_by(id) %>% summarise_at(.vars = samples, .funs = sum) %>% as.data.frame()
  if (consensus == T) {
    j$tpm <- rowSums(j %>% mutate(id = NULL))
    j <- j %>% dplyr::select(id, tpm)
  } 
  data <- left_join(mcols(gr) %>% as.data.frame(), j) %>% mutate(id = NULL)
  
  if (return.se == T) {
    se <- SummarizedExperiment::SummarizedExperiment(rowRanges = gr, 
                                                     assays = list(tpm = data))
    return(se)
  }
  mcols(gr) <- data
  return(gr)
}



sync.o.anno.rmbl <- function(sync.o, anno = T, rmbl = T, genome) {
  if (annotate == T) {
    if (genome == "mm10") {
      genome.name <- "BSgenome.Mmusculus.UCSC.mm10"
      annoDb <- "org.Mm.eg.db"
      #annoDb <- NULL
      # TxDb <- TxDb.Mmusculus.UCSC.mm10.knownGene::TxDb.Mmusculus.UCSC.mm10.knownGene
      TxDb <- AnnotationDbi::loadDb(file = "~/genomes/mm10/gencode/TxDb.mm10.gencode.v24.klraps.sqlite")
    }
    
    if (genome == "hg38") {
      genome.name <- "BSgenome.Hsapiens.UCSC.hg38"
      # annoDb <- "org.Hs.eg.db"
      TxDb <- TxDb.Hsapiens.UCSC.hg38.knownGene::TxDb.Hsapiens.UCSC.hg38.knownGene
    }
    # browser()
    anno <- sync.o$j %>%
      ChIPseeker::annotatePeak(TxDb=TxDb, annoDb = annoDb)
    if (length(anno@anno) != length(sync.o$j)) {
      stop ("length(anno@anno) != length(j)")
    }
    sync.o$j <- anno@anno
    rm(anno)
  }
  
  if (rmbl == T) {
    bl <- rtracklayer::import.bed(paste0("~/genomes/", genome, "/blacklist/", genome, ".blacklist.bed"))
    sync.o$j <- plyranges::filter_by_non_overlaps(x = syn.o$j, y = bl)
    sync.o$cage.se <- sync.o$cage.se[sync.o$j$cage.id]
    sync.o$atac.se <- sync.o$atac.se[sync.o$j$atac.id]
    sync.o$atac.se <- se.fast.normalize(sync.o$atac.se, factor = metadata(sync.o$atac.se)$scale.factor, slot.name = "cpm")
  }
  
  return(sync.o)
}


sync.o.validate <- function(sync.o, recompute.cpm = F, enforce.cpm = T) {
  
}

sync.o.gen.ez <- function(cage.se, atac.se, j = NULL, use.cage.as.j = T) {
  # this is a simple way to generate sync.o. Here the rowRanges of the 2 se objects, 
  #although not necessarily the same, are corresponding to each other. which means 
  #the correspodance between rowRanges(cage.se)[i] and rowRanges(atac.se)[i] is already established
  if (is.null(j)) {
    if (use.cage.as.j == T)
      j <- rowRanges(cage.se)
    else
      j <- rowRanges(atac.se)
  }
  
  
}




create.histone.se <- function(gr, gr.center = T, gr.keep.meta = F,
                              buffer.up, buffer.down, samples.df, bSingleEnd,
                              scale.factor = 1000000, out.dir, root.name) {
  if (is.character(samples.df))
    samples.df <- read.table(samples.df, as.is = T, header = T)
  warning("please note the strandness of gr. This function is heavily stranded!!")
  utilsFanc::write.zip.fanc(df = gr, out.file = paste0(out.dir, "/", root.name,"_inputRegions.bed"),
                            bed.shift = T)
  if (gr.center == T)
    gr <- utilsFanc::gr.center(gr = gr) 
  if (gr.keep.meta == F)
    mcols(gr) <- NULL
  if (buffer.up != 0 || buffer.down != 0) {
    gr <- flank(gr, width = buffer.up, start = T, both = F, ignore.strand = F) %>% 
    resize(width = buffer.up + buffer.down, fix = "start", ignore.strand = F)
  }
  utilsFanc::write.zip.fanc(df = gr, out.file = paste0(out.dir, "/", root.name,"_rowRanges.bed"),
                            bed.shift = T)
  utilsFanc::write.zip.fanc(df = gr[sample(1:length(gr), 100, replace = T)], 
                            out.file = paste0(out.dir, "/", root.name,"_rowRanges_peakwatch.bed"),
                            bed.shift = T)
  se <- GenomicAlignments::summarizeOverlaps(features = gr, reads = samples.df$bamfile, 
                                             mode = "Union", inter.feature = F,
                                             singleEnd = bSingleEnd, fragments = F,
                                             ignore.strand = T)
  name.map <- samples.df$sample
  names(name.map) <- basename(samples.df$bamfile)
  colnames(se) <- name.map[colnames(se)]
  ## testing info in bamFanc/R/debug_summarizeOverlaps.R
  se <- se.fast.normalize(se = se, factor = scale.factor, slot.name = "cpm")
  rownames(se) <- NULL
  
  coldata <- samples.df
  rownames(coldata) <- coldata$sample
  coldata <- coldata[colnames(se),]
  colData(se) <- coldata %>% as("DataFrame")

  saveRDS(se, paste0(out.dir, "/", root.name, ".Rds"))
  return(se)
}

